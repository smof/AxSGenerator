#!/usr/bin/env ruby
#Simon Moffatt Jan 2013
#Creates a CSV file of random entitlements assigned to a unique ID.  Useful for populating LDAP/databases for ACL testing
#Requires a user input file of full names.  Can be generated by NameGenerator - http://www.github.com/smof/NameGenerator

#requires
require 'rubygems'
require 'date'
require 'csv'
require 'set'

#Globals and constants#######################################################################
INPUT_NAMES="1k_HR_Users.csv" #one userid per line
INPUT_ENTITLEMENTS="db_entitlements.csv" #one entitlement per line
RANDOMIZE_NUMER_OF_ENTITLEMENTS = true #if false can set ENTITLEMENTS_PER_USER
ENTITLEMENTS_PER_USER = 5 #valid if randomize = false. must be < entitlements.length otherwise defaults to total_entitlements * 0.6
RESOURCE="mysql" #name of resource
OUTPUT_FILE="#{RESOURCE}_generated_entitlements.csv"
COMPLETED_USERS=[] #where all user arrays end up
MULTIVALUE_DELIMITER=";"
COLUMN_SEPARATOR=","
@processed_records = 0 #just for reporting
#Globals and constants#######################################################################

#reads in full names file
def read_ids

  puts "Reading ID's file"

  #iterate over csv of identies and push into array
  @ids =[]
  CSV.foreach(INPUT_NAMES) do |row|
    
    @ids << row[0] #only want first entry in array line
        
  end

  puts "Reading ID's file - FINISHED - #{@ids.length} processed"
  
end

=begin
#creates unique ids - deprecated
def create_ids
      
  @ids =[] #unique ids
  
  #map each fullname to a uuid   
  @names.collect! do |name|
    
    first_time_found = true
    #split fullname into two elements, taking first char of first element added to second element
    user_id = name[0].split(" ")[0][0] + name[0].split(" ")[1]  
    
    #check that generated user_id is unique
    while @ids.include? user_id
      user_id += 0.to_s if first_time_found #only add on integer once at begining of incremental process
      user_id.succ! #increments integer at end
      first_time_found = false
    end
    
    #populates array of uuids for checking
    @ids << user_id
           
    #add unique id then fullname to array for use later on...
    name[0] + "#{COLUMN_SEPARATOR}" + user_id
                       
  end 
       
end
=end


#suck entitlements list from CSV file
def read_entitlements
  
  puts "Reading entitlements file"

  @entitlements =[]
  CSV.foreach(INPUT_ENTITLEMENTS) do |row|
    
    @entitlements << row[0] #push entitlements pool into an array
    
  end

  puts "Reading entitlements file - FINISHED - #{@entitlements.length} processed"	   

end


def create_random_entitlements
  
  COMPLETED_USERS << "id#{COLUMN_SEPARATOR}entitlements"  

  puts "Generating entitlements"
  
  #names now contains fullname and uuid from create_ids
  @ids.each do |id|
            
        COMPLETED_USERS << "#{id}#{COLUMN_SEPARATOR}#{generated_entitlements}"
            
  end
  
end


#randomly pulls out a single entitlement from the pumped in list of entitlements via csv file
def get_entitlement
  
   @entitlements[Kernel.rand(@entitlements.length-1)] # @entitlements global set in read_entitlements

end


#creates a bunch entitlements for a particular user
def generated_entitlements

  processed_record ="." #just for STDERR print out
    
  #generated_entitlements = "" #init empty string per call to method
  generated_entitlements = Set.new
 
  entitlements_per_user = (@entitlements.length*0.6).floor

  if RANDOMIZE_NUMER_OF_ENTITLEMENTS == true
  
	  #only pull out up to half of all given entitlements
	  1.upto(Kernel.rand(entitlements_per_user).floor) {
   	
 	           new_entitlement = get_entitlement
			
			Thread.new do      
			
				while generated_entitlements.include? new_entitlement
	        
			        	new_entitlement = get_entitlement
        			
		   		end	  
			end

	           @processed_records += 1
                   generated_entitlements << new_entitlement
               
	  }
	  
  else

	 1.upto(ENTITLEMENTS_PER_USER < @entitlements.length ? ENTITLEMENTS_PER_USER : @entitlements.length * 0.6) {
    
	      new_entitlement = get_entitlement
      
	      while generated_entitlements.include? new_entitlement
        
        		new_entitlement = get_entitlement
        
	      end   
      
	      @processed_records += 1
	      generated_entitlements += "#{MULTIVALUE_DELIMITER}#{new_entitlement}"
		     
	 }
  
  end
  
  STDERR.print processed_record

  #convert array in to string  
  string_entitlements = ""
  generated_entitlements.each {|entitlement| string_entitlements += "#{entitlement}#{MULTIVALUE_DELIMITER}"} 
  #remove last char which is delimiter
  string_entitlements.slice!(0...-1)
    
end
   

#writes out to new entitlements file specific for that resource
def write_entitlements
  
  puts "\nWriting Entitlements"

  new_entitlements_file = File.open(OUTPUT_FILE, 'w')
  COMPLETED_USERS.each do |user| new_entitlements_file.puts user.to_s end #basic puts but driven to open file
  new_entitlements_file.close #closes
  #puts "Writing Entitlements...FINISHED - #{@processed_records} entitlements created for #{@ids.length} userids"
  puts "Writing Entitlements - FINISHED - #{@processed_records} entitlements created for #{@ids.length} userids"
  puts "Started - #{@started}" 
  puts "Ended - #{Time.now}"

end


#Run Through

@started = Time.now
read_entitlements
read_ids
#create_ids
create_random_entitlements
write_entitlements

 
