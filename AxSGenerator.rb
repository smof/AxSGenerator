#!/usr/bin/env ruby
#Simon Moffatt Jan 2013
#Creates a CSV file of random entitlements assigned to a unique ID.  Useful for populating LDAP/databases for ACL testing
#Requires a user input file of full names.  Can be generated by NameGenerator - http://www.github.com/smof/NameGenerator

#requires
require 'rubygems'
require 'date'
require 'csv'

#Globals and constants#######################################################################
INPUT_NAMES="names.dat" #one user per line in format "firstname lastname"
INPUT_ENTITLEMENTS="entitlements.csv" #one entitlements per line
RANDOMIZE_NUMER_OF_ENTITLEMENTS = true #if false can set ENTITLEMENTS_PER_USER
ENTITLEMENTS_PER_USER = 20 #valid if randomize = false. must be < entitlements.length otherwise defaults to total_entitlements * 0.6
RESOURCE="AD" #name of resource
OUTPUT_FILE="#{RESOURCE}_generated_entitlements.csv"
COMPLETED_USERS=[] #where all user arrays end up
MULTIVALUE_DELIMITER=";"
COLUMN_SEPARATOR=","
@processed_records = 0 #just for reporting
#Globals and constants#######################################################################

#reads in full names file
def read_names

  puts "Reading names file..."

  #iterate over csv of identies and ip's, each row is passed to row[] and each field in row passed to generate_entitlement
  @names =[]
  CSV.foreach(INPUT_NAMES) do |row|
    
    @names << row
        
  end

  puts "Reading names file...FINISHED"
  
end

#creates unique ids
def create_ids
      
  @ids =[] #unique ids
  
  #map each fullname to a uuid   
  @names.collect! do |name|
    
    first_time_found = true
    #split fullname into two elements, taking first char of first element added to second element
    user_id = name[0].split(" ")[0][0] + name[0].split(" ")[1]  
    
    #check that generated user_id is unique
    while @ids.include? user_id
      user_id += 0.to_s if first_time_found #only add on integer once at begining of incremental process
      user_id.succ! #increments integer at end
      first_time_found = false
    end
    
    #populates array of uuids for checking
    @ids << user_id
           
    #add unique id then fullname to array for use later on...
    name[0] + "," + user_id
                       
  end 
       
end


#suck entitlements list from CSV file
def read_entitlements
  
  puts "Reading entitlements file..."

  @entitlements =[]
  CSV.foreach(INPUT_ENTITLEMENTS) do |row|
    
    @entitlements << row[0] #push entitlements pool into an array
    
  end

  puts "Reading entitlements file...FINISHED"	   

end


def create_random_entitlements
  
  COMPLETED_USERS << "fullname#{COLUMN_SEPARATOR}userid#{COLUMN_SEPARATOR}entitlements"
  
  puts "Generating entitlements..."
  
  #names now contains fullname and uuid from create_ids
  @names.each do |name|
            
        COMPLETED_USERS << "#{name}#{COLUMN_SEPARATOR}#{generated_entitlements}"
            
  end
  
end


#randomly pulls out a single entitlement from the pumped in list of entitlements via csv file
def get_entitlement
  
   @entitlements[Kernel.rand(@entitlements.length-1)] # @entitlements global set in read_entitlements

end


#creates a bunch entitlements for a particular user
def generated_entitlements

  processed_record ="." #just for STDERR print out
    
  generated_entitlements = "" #init empty string per call to method
  
  if RANDOMIZE_NUMER_OF_ENTITLEMENTS == true
  
	  1.upto(Kernel.rand(@entitlements.length)) {
        
      new_entitlement = get_entitlement
      
      while generated_entitlements.include? new_entitlement
        
        new_entitlement = get_entitlement
        
      end	  
      
      @processed_records += 1
      generated_entitlements += "#{MULTIVALUE_DELIMITER}#{new_entitlement}"
               
	  }
	  
  else

	 1.upto(ENTITLEMENTS_PER_USER < @entitlements.length ? ENTITLEMENTS_PER_USER : @entitlements.length*0.6) {
    
      new_entitlement = get_entitlement
      
      while generated_entitlements.include? new_entitlement
        
        new_entitlement = get_entitlement
        
      end   
      
      @processed_records += 1
      generated_entitlements += "#{MULTIVALUE_DELIMITER}#{new_entitlement}"
	     
	     
	 }
  
  end
  
  STDERR.print processed_record
  
  #nasty hack to remove pre-fixed ",".  Need to stop , being added
  generated_entitlements.slice!(0)
    
  return generated_entitlements
    
end
   

#writes out to new entitlements file specific for that resource
def write_entitlements
  
  puts "\nWriting Entitlements..."

  new_entitlements_file = File.open(OUTPUT_FILE, 'w')
  COMPLETED_USERS.each do |user| new_entitlements_file.puts user.to_s end #basic puts but driven to open file
  new_entitlements_file.close #closes
  puts "Writing Entitlements...FINISHED - #{@processed_records} entitlements created for #{@ids.length} userids"
  puts "Started - #{@started}" 
  puts "Ended - #{Time.now}"

end


#Run Through

@started = Time.now
read_entitlements
read_names
create_ids
create_random_entitlements
write_entitlements

 